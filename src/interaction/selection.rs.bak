//! Atom selection system
//!
//! This system handles atom selection via raycasting and manages
//! the selection state for interaction with atoms.

use bevy::prelude::*;
use bevy_mod_picking::prelude::*;

/// Resource tracking the current selection state
#[derive(Resource, Default, Debug, Clone)]
pub struct SelectionState {
    /// List of selected atom entities
    pub selected_entities: Vec<Entity>,
    /// Last selected entity (for single-select operations)
    pub last_selected: Option<Entity>,
    /// Selection mode (single, multiple, box)
    pub mode: SelectionMode,
}

impl SelectionState {
    /// Create a new empty selection state
    pub fn new() -> Self {
        Self::default()
    }

    /// Check if an entity is selected
    pub fn is_selected(&self, entity: Entity) -> bool {
        self.selected_entities.contains(&entity)
    }

    /// Get the number of selected entities
    pub fn len(&self) -> usize {
        self.selected_entities.len()
    }

    /// Check if selection is empty
    pub fn is_empty(&self) -> bool {
        self.selected_entities.is_empty()
    }

    /// Clear all selections
    pub fn clear(&mut self) {
        self.selected_entities.clear();
        self.last_selected = None;
    }

    /// Add an entity to selection
    pub fn add(&mut self, entity: Entity) {
        if !self.selected_entities.contains(&entity) {
            self.selected_entities.push(entity);
            self.last_selected = Some(entity);
        }
    }

    /// Remove an entity from selection
    pub fn remove(&mut self, entity: Entity) {
        self.selected_entities.retain(|&e| e != entity);
        if self.last_selected == Some(entity) {
            self.last_selected = self.selected_entities.last().copied();
        }
    }

    /// Toggle selection of an entity
    pub fn toggle(&mut self, entity: Entity) {
        if self.is_selected(entity) {
            self.remove(entity);
        } else {
            self.add(entity);
        }
    }

    /// Replace selection with a single entity
    pub fn set(&mut self, entity: Entity) {
        self.selected_entities.clear();
        self.selected_entities.push(entity);
        self.last_selected = Some(entity);
    }

    /// Get all selected entities
    pub fn entities(&self) -> &[Entity] {
        &self.selected_entities
    }
}

/// Selection mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SelectionMode {
    /// Single selection (replace current selection)
    #[default]
    Single,
    /// Multiple selection (add to selection)
    Multiple,
    /// Box selection (select atoms in region)
    Box,
}

/// Marker component for selected atoms
#[derive(Component)]
pub struct Selected;

/// Event sent when an atom is selected
#[derive(Event, Debug)]
pub struct AtomSelectedEvent {
    pub entity: Entity,
}

/// Event sent when an atom is deselected
#[derive(Event, Debug)]
pub struct AtomDeselectedEvent {
    pub entity: Entity,
}

/// Event sent when selection is cleared
#[derive(Event, Debug)]
pub struct SelectionClearedEvent;

/// Handle atom selection via clicking
pub fn handle_atom_selection(
    mut commands: Commands,
    mut selection: ResMut<SelectionState>,
    mut selected_events: EventWriter<AtomSelectedEvent>,
    mut deselected_events: EventWriter<AtomDeselectedEvent>,
    mouse: Res<ButtonInput<MouseButton>>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mut atom_query: Query<
        (Entity, &Pointer<Click>, Option<&Selected>),
        With<crate::systems::spawning::SpawnedAtom>,
    >,
) {
    // Check for left-click on atoms
    for (entity, click, is_selected) in atom_query.iter_mut() {
        if click.is_just_pressed() {
            let is_shift_held = keyboard.pressed(KeyCode::ShiftLeft) || keyboard.pressed(KeyCode::ShiftRight);
            let is_ctrl_held = keyboard.pressed(KeyCode::ControlLeft) || keyboard.pressed(KeyCode::ControlRight);

            // Determine selection action based on modifiers
            let action = if is_shift_held || is_ctrl_held {
                SelectionAction::Toggle
            } else {
                SelectionAction::Set
            };

            match action {
                SelectionAction::Set => {
                    // Clear existing selection and select this atom
                    // Deselect all currently selected atoms
                    for selected_entity in selection.entities().iter().copied().collect::<Vec<_>>() {
                        if selected_entity != entity {
                            commands.entity(selected_entity).remove::<Selected>();
                            deselected_events.send(AtomDeselectedEvent { entity: selected_entity });
                        }
                    }

                    // Select or deselect the clicked atom
                    if is_selected.is_some() {
                        commands.entity(entity).remove::<Selected>();
                        selection.remove(entity);
                        deselected_events.send(AtomDeselectedEvent { entity });
                    } else {
                        commands.entity(entity).insert(Selected);
                        selection.set(entity);
                        selected_events.send(AtomSelectedEvent { entity });
                    }
                }
                SelectionAction::Toggle => {
                    // Toggle selection of clicked atom
                    commands.entity(entity).insert(Selected);
                    selection.toggle(entity);
                    if selection.is_selected(entity) {
                        selected_events.send(AtomSelectedEvent { entity });
                    } else {
                        commands.entity(entity).remove::<Selected>();
                        deselected_events.send(AtomDeselectedEvent { entity });
                    }
                }
            }

            info!("Atom {:?} selected (total: {})", entity, selection.len());
        }
    }

    // Handle deselect all (Escape key)
    if keyboard.just_pressed(KeyCode::Escape) && !selection.is_empty() {
        for selected_entity in selection.entities().iter().copied().collect::<Vec<_>>() {
            commands.entity(selected_entity).remove::<Selected>();
            deselected_events.send(AtomDeselectedEvent { entity: selected_entity });
        }

        selection.clear();
        commands.trigger(SelectionClearedEvent);
        info!("Selection cleared");
    }
}

/// Selection action type
enum SelectionAction {
    /// Replace current selection with clicked atom
    Set,
    /// Toggle selection of clicked atom
    Toggle,
}

/// Update atom highlighting based on selection state
pub fn update_selection_highlight(
    mut commands: Commands,
    selection: Res<SelectionState>,
    mut atom_query: Query<(Entity, Option<&Selected>, &mut Handle<StandardMaterial>), With<crate::systems::spawning::SpawnedAtom>>,
    materials: Res<Assets<StandardMaterial>>,
) {
    // Note: This is a simplified approach. In a production system, you would
    // create separate highlight materials or use emissive colors.

    // For now, we rely on the Selected component to indicate selection state
    // The visual highlighting is handled through material changes or additional components
}

/// Selection box visualization (for box selection mode)
#[derive(Component)]
pub struct SelectionBox;

/// Draw selection box when in box selection mode
pub fn draw_selection_box(
    mut commands: Commands,
    selection: Res<SelectionState>,
    mouse: Res<ButtonInput<MouseButton>>,
    keyboard: Res<ButtonInput<KeyCode>>,
    windows: Query<&Window>,
    camera_q: Query<(&Camera, &GlobalTransform)>,
) {
    // Box selection is not yet implemented
    // This would require mouse drag detection and raycasting to a plane
}

/// Clear selection when a new file is loaded
pub fn clear_selection_on_load(
    mut commands: Commands,
    mut selection: ResMut<SelectionState>,
    mut file_loaded_events: EventReader<crate::systems::loading::FileLoadedEvent>,
    mut cleared_event: EventWriter<SelectionClearedEvent>,
) {
    if !file_loaded_events.is_empty() && !selection.is_empty() {
        // Deselect all atoms
        for selected_entity in selection.entities().iter().copied().collect::<Vec<_>>() {
            commands.entity(selected_entity).remove::<Selected>();
        }

        selection.clear();
        cleared_event.send(SelectionClearedEvent);
        info!("Selection cleared on file load");
    }
}

/// Register all selection systems
pub fn register(app: &mut App) {
    app.init_resource::<SelectionState>()
        .add_event::<AtomSelectedEvent>()
        .add_event::<AtomDeselectedEvent>()
        .add_event::<SelectionClearedEvent>()
        .add_systems(Update, handle_atom_selection)
        .add_systems(Update, update_selection_highlight)
        .add_systems(Update, clear_selection_on_load);

    info!("Atom selection systems registered");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_selection_state() {
        let mut selection = SelectionState::new();
        assert!(selection.is_empty());
        assert_eq!(selection.len(), 0);

        let entity = Entity::PLACEHOLDER;
        selection.add(entity);
        assert_eq!(selection.len(), 1);
        assert!(selection.is_selected(entity));

        selection.remove(entity);
        assert!(selection.is_empty());

        selection.set(entity);
        assert!(selection.is_selected(entity));

        selection.clear();
        assert!(selection.is_empty());
    }

    #[test]
    fn test_selection_toggle() {
        let mut selection = SelectionState::new();
        let entity = Entity::PLACEHOLDER;

        selection.toggle(entity);
        assert!(selection.is_selected(entity));

        selection.toggle(entity);
        assert!(!selection.is_selected(entity));
    }
}
